<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Collage Editor (300×100)</title>
    <style>
      :root {
        --bg: #fde7ee; /* light pink pastel background */
        --borderOuter: #f6c7d6; /* pastel pink outer border */
        --borderInner: #fff4f7; /* pale inner border */
        --shadow: rgba(0, 0, 0, 0.12);
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: #fafafa;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
        color: #333;
      }

      .wrap {
        width: min(920px, 92vw);
        display: grid;
        gap: 14px;
        justify-items: center;
      }

      .toolbar {
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        background: #fff;
        border: 1px solid #eee;
        border-radius: 12px;
        padding: 10px 12px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.04);
      }

      .toolbar .left,
      .toolbar .right {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        border: 1px solid #e7e7e7;
        background: #fff;
        padding: 8px 10px;
        border-radius: 10px;
        cursor: pointer;
      }
      button:hover {
        background: #f7f7f7;
      }

      .hint {
        font-size: 13px;
        opacity: 0.8;
        line-height: 1.3;
      }

      /* The “final output” area */
      .stage {
        width: 900px;
        height: 300px;
        background: var(--bg);
        border: 6px solid var(--borderOuter); /* external border */
        border-radius: 12px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.1);
        user-select: none;
        touch-action: none;
      }

      /* Each draggable card */
      .card {
        position: absolute;
        width: 110px; /* you can adjust default sizes */
        height: 74px;
        transform-origin: 50% 50%;
        cursor: grab;
        border-radius: 10px;
        box-shadow: 0 10px 16px var(--shadow);
        border: 5px solid var(--borderOuter); /* internal border */
        background: var(--borderOuter);
      }

      .card:active {
        cursor: grabbing;
      }

      .card.selected {
        outline: 2px dashed rgba(0, 0, 0, 0.25);
        outline-offset: 6px;
      }

      .card .inner {
        width: 100%;
        height: 100%;
        border-radius: 7px;
        border: 5px solid var(--borderInner); /* inner matte */
        overflow: hidden;
        background: #fff;
      }

      .card img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        pointer-events: none;
      }

      /* Small footer for download hint */
      .small {
        font-size: 12px;
        opacity: 0.75;
        text-align: center;
        max-width: 70ch;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="toolbar">
        <div class="left">
          <button id="resetBtn" type="button">Reset</button>
          <button id="exportBtn" type="button">Export PNG</button>
          <span class="hint"> Drag to move • Click to select • R / Shift+R rotate • + / - scale • Delete hides </span>
        </div>
        <div class="right">
          <span class="hint">Canvas: 300×100</span>
        </div>
      </div>

      <div class="stage" id="stage" aria-label="Collage stage 300 by 100">
        <!-- Cards -->
        <div class="card" data-name="bedroom" style="left: 10px; top: 18px; transform: rotate(-10deg) scale(1); z-index: 1">
          <div class="inner">
            <img src="bedroom.jpg" alt="Bedroom 1" />
          </div>
        </div>

        <div class="card" data-name="bedroom1" style="left: 96px; top: 10px; transform: rotate(-3deg) scale(1); z-index: 2">
          <div class="inner">
            <img src="bedroom1.png" alt="Bedroom 2" />
          </div>
        </div>

        <div class="card" data-name="dining" style="left: 185px; top: 18px; transform: rotate(10deg) scale(1); z-index: 3">
          <div class="inner">
            <img src="dining.jpg" alt="Dining" />
          </div>
        </div>
      </div>

      <div class="small">Tip: once you’ve arranged it, click <b>Export PNG</b> to download a 300×100 image.</div>
    </div>

    <script>
      const stage = document.getElementById("stage");
      const cards = Array.from(stage.querySelectorAll(".card"));
      const resetBtn = document.getElementById("resetBtn");
      const exportBtn = document.getElementById("exportBtn");

      let selected = null;
      let drag = null; // {card, startX, startY, origLeft, origTop}

      // Keep original layout for Reset
      const initial = cards.map((c) => ({
        name: c.dataset.name,
        left: c.style.left,
        top: c.style.top,
        transform: c.style.transform,
        z: c.style.zIndex,
      }));

      function selectCard(card) {
        cards.forEach((c) => c.classList.remove("selected"));
        selected = card;
        if (selected) {
          selected.classList.add("selected");
          bringToFront(selected);
        }
      }

      function bringToFront(card) {
        const maxZ = Math.max(...cards.map((c) => Number(c.style.zIndex || 1)));
        card.style.zIndex = String(maxZ + 1);
      }

      function getTransformParts(card) {
        // expects: rotate(Xdeg) scale(Y)
        const t = card.style.transform || "rotate(0deg) scale(1)";
        const rotMatch = t.match(/rotate\(([-\d.]+)deg\)/);
        const scaleMatch = t.match(/scale\(([-\d.]+)\)/);
        return {
          rot: rotMatch ? parseFloat(rotMatch[1]) : 0,
          scale: scaleMatch ? parseFloat(scaleMatch[1]) : 1,
        };
      }

      function setTransform(card, rot, scale) {
        card.style.transform = `rotate(${rot}deg) scale(${scale})`;
      }

      function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      function pointerDown(e) {
        const card = e.target.closest(".card");
        if (!card) {
          selectCard(null);
          return;
        }

        e.preventDefault();
        selectCard(card);

        const rect = stage.getBoundingClientRect();
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

        drag = {
          card,
          startX: x,
          startY: y,
          origLeft: parseFloat(card.style.left || 0),
          origTop: parseFloat(card.style.top || 0),
        };
      }

      function pointerMove(e) {
        if (!drag) return;

        const rect = stage.getBoundingClientRect();
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

        const dx = x - drag.startX;
        const dy = y - drag.startY;

        // Move freely; you can clamp if you want to keep inside
        drag.card.style.left = drag.origLeft + dx + "px";
        drag.card.style.top = drag.origTop + dy + "px";
      }

      function pointerUp() {
        drag = null;
      }

      stage.addEventListener("mousedown", pointerDown);
      stage.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      stage.addEventListener("touchstart", pointerDown, { passive: false });
      stage.addEventListener("touchmove", pointerMove, { passive: false });
      window.addEventListener("touchend", pointerUp);

      // Click selection (for when user clicks without dragging)
      stage.addEventListener("click", (e) => {
        const card = e.target.closest(".card");
        if (card) selectCard(card);
      });

      // Keyboard controls for selected card
      window.addEventListener("keydown", (e) => {
        if (!selected) return;

        const parts = getTransformParts(selected);

        // Rotate
        if (e.key === "r" || e.key === "R") {
          const delta = e.shiftKey ? -2 : 2;
          setTransform(selected, parts.rot + delta, parts.scale);
        }

        // Scale
        if (e.key === "+" || e.key === "=") {
          setTransform(selected, parts.rot, clamp(parts.scale + 0.05, 0.4, 2.5));
        }
        if (e.key === "-" || e.key === "_") {
          setTransform(selected, parts.rot, clamp(parts.scale - 0.05, 0.4, 2.5));
        }

        // Nudge position
        const step = e.shiftKey ? 5 : 2;
        if (e.key === "ArrowLeft") selected.style.left = parseFloat(selected.style.left || 0) - step + "px";
        if (e.key === "ArrowRight") selected.style.left = parseFloat(selected.style.left || 0) + step + "px";
        if (e.key === "ArrowUp") selected.style.top = parseFloat(selected.style.top || 0) - step + "px";
        if (e.key === "ArrowDown") selected.style.top = parseFloat(selected.style.top || 0) + step + "px";

        // Hide (soft delete)
        if (e.key === "Delete" || e.key === "Backspace") {
          selected.style.display = "none";
          selected = null;
        }
      });

      // Reset
      resetBtn.addEventListener("click", () => {
        cards.forEach((c) => (c.style.display = ""));
        initial.forEach((s) => {
          const card = cards.find((c) => c.dataset.name === s.name);
          if (!card) return;
          card.style.left = s.left;
          card.style.top = s.top;
          card.style.transform = s.transform;
          card.style.zIndex = s.z;
        });
        selectCard(null);
      });

      // Export PNG (300×100)
      exportBtn.addEventListener("click", async () => {
        // Draw the stage to a canvas manually (no libraries).
        // This exports the *visible* layout (borders, rotations, scaling).
        const canvas = document.createElement("canvas");
        canvas.width = 300;
        canvas.height = 100;
        const ctx = canvas.getContext("2d");

        // Background + outer border
        ctx.fillStyle = getComputedStyle(stage).backgroundColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Outer border thickness is 6px in CSS
        ctx.strokeStyle = getComputedStyle(stage).borderColor;
        ctx.lineWidth = 6;
        ctx.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);

        // Draw cards in z order
        const ordered = [...cards]
          .filter((c) => c.style.display !== "none")
          .sort((a, b) => Number(a.style.zIndex || 0) - Number(b.style.zIndex || 0));

        for (const card of ordered) {
          const img = card.querySelector("img");
          await img.decode().catch(() => {});

          const left = parseFloat(card.style.left || 0);
          const top = parseFloat(card.style.top || 0);

          const { rot, scale } = getTransformParts(card);

          // Base card size from CSS
          const baseW = card.getBoundingClientRect().width;
          const baseH = card.getBoundingClientRect().height;

          // Convert DOM pixels to canvas pixels (stage is fixed 300×100)
          // stageRect is used to scale if browser zoom affects sizes
          const stageRect = stage.getBoundingClientRect();
          const sx = canvas.width / stageRect.width;
          const sy = canvas.height / stageRect.height;

          const w = baseW * sx;
          const h = baseH * sy;
          const x = left * sx;
          const y = top * sy;

          // Borders
          const outer = 5 * sx; // card outer border
          const inner = 5 * sx; // matte border

          // Rotate around centre of card
          ctx.save();
          ctx.translate(x + w / 2, y + h / 2);
          ctx.rotate((rot * Math.PI) / 180);

          // Outer border rectangle
          ctx.fillStyle = getComputedStyle(card).borderColor;
          roundRect(ctx, -w / 2, -h / 2, w, h, 10 * sx);
          ctx.fill();

          // Inner matte
          const matteX = -w / 2 + outer;
          const matteY = -h / 2 + outer;
          const matteW = w - outer * 2;
          const matteH = h - outer * 2;

          ctx.fillStyle = getComputedStyle(card.querySelector(".inner")).borderColor;
          roundRect(ctx, matteX, matteY, matteW, matteH, 8 * sx);
          ctx.fill();

          // Image area
          const imgX = matteX + inner;
          const imgY = matteY + inner;
          const imgW = matteW - inner * 2;
          const imgH = matteH - inner * 2;

          // cover-crop like object-fit: cover
          drawCover(ctx, img, imgX, imgY, imgW, imgH);

          ctx.restore();
        }

        const a = document.createElement("a");
        a.href = canvas.toDataURL("image/png");
        a.download = "collage-300x100.png";
        a.click();
      });

      function roundRect(ctx, x, y, w, h, r) {
        r = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      }

      function drawCover(ctx, img, x, y, w, h) {
        const iw = img.naturalWidth;
        const ih = img.naturalHeight;
        if (!iw || !ih) return;

        const scale = Math.max(w / iw, h / ih);
        const sw = w / scale;
        const sh = h / scale;
        const sx = (iw - sw) / 2;
        const sy = (ih - sh) / 2;

        ctx.save();
        // clip to the image rectangle so it stays clean
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.clip();

        ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
        ctx.restore();
      }

      // Default: select centre card on load
      selectCard(cards[1]);
    </script>
  </body>
</html>
